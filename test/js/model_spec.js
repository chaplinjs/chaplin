// Generated by CoffeeScript 1.4.0
var __hasProp = {}.hasOwnProperty;

define(['underscore', 'chaplin/mediator', 'chaplin/models/model', 'chaplin/lib/event_broker'], function(_, mediator, Model, EventBroker) {
  'use strict';
  return describe('Model', function() {
    var model;
    model = null;
    beforeEach(function() {
      return model = new Model({
        id: 1,
        foo: 'foo'
      });
    });
    afterEach(function() {
      return model.dispose();
    });
    it('should mixin a EventBroker', function() {
      var name, value, _results;
      _results = [];
      for (name in EventBroker) {
        if (!__hasProp.call(EventBroker, name)) continue;
        value = EventBroker[name];
        _results.push(expect(model[name]).to.be(EventBroker[name]));
      }
      return _results;
    });
    it('should initialize a Deferred', function() {
      var method, _i, _len, _ref;
      expect(model.initDeferred).to.be.a('function');
      model.initDeferred();
      _ref = ['done', 'fail', 'progress', 'state', 'promise'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        method = _ref[_i];
        expect(typeof model[method]).to.be('function');
      }
      return expect(model.state()).to.be('pending');
    });
    it('should return the attributes per default', function() {
      return expect(model.getAttributes()).to.be(model.attributes);
    });
    it('should serialize the attributes', function() {
      var actual, collection, expected, model1, model2, model3, model4, model5;
      model1 = model;
      model2 = new Model({
        id: 2,
        bar: 'bar'
      });
      model3 = new Model({
        id: 3,
        qux: 'qux'
      });
      model4 = new Model({
        id: 4,
        foo: 'foo'
      });
      model5 = new Model({
        id: 5,
        baz: 'baz'
      });
      collection = new Backbone.Collection([model4, model5]);
      model1.set({
        model2: model2
      });
      model2.set({
        model3: model3
      });
      model2.set({
        collection: collection
      });
      model2.set({
        model2: model2
      });
      model3.set({
        model2: model2
      });
      actual = model.serialize();
      expected = {
        foo: 'foo',
        model2: {
          bar: 'bar',
          model2: null,
          model3: {
            qux: 'qux',
            model2: null
          },
          collection: [
            {
              foo: 'foo'
            }, {
              baz: 'baz'
            }
          ]
        }
      };
      expect(actual).to.be.an('object');
      expect(actual.foo).to.be(expected.foo);
      expect(actual.model2).to.be.an('object');
      expect(actual.model2.bar).to.be(expected.model2.bar);
      expect(actual.model2.model2).to.be(expected.model2.model2);
      expect(actual.model2.collection).to.be.an('array');
      expect(actual.model2.collection[0].foo).to.be(expected.model2.collection[0].foo);
      expect(actual.model2.collection[1].baz).to.be(expected.model2.collection[1].baz);
      expect(actual.model2.model3).to.be.an('object');
      expect(actual.model2.model3.qux).to.be(expected.model2.model3.qux);
      return expect(actual.model2.model3.model2).to.be(expected.model2.model3.model2);
    });
    it('should dispose itself correctly', function() {
      expect(model.dispose).to.be.a('function');
      model.dispose();
      expect(model.disposed).to.be(true);
      if (Object.isFrozen) {
        return expect(Object.isFrozen(model)).to.be(true);
      }
    });
    it('should fire a dispose event', function() {
      var disposeSpy;
      disposeSpy = sinon.spy();
      model.on('dispose', disposeSpy);
      model.dispose();
      return expect(disposeSpy).was.called();
    });
    it('should unsubscribe from Pub/Sub events', function() {
      var pubSubSpy;
      pubSubSpy = sinon.spy();
      model.subscribeEvent('foo', pubSubSpy);
      model.dispose();
      mediator.publish('foo');
      return expect(pubSubSpy).was.notCalled();
    });
    it('should remove all event handlers from itself', function() {
      var modelBindSpy;
      modelBindSpy = sinon.spy();
      model.on('foo', modelBindSpy);
      model.dispose();
      model.trigger('foo');
      return expect(modelBindSpy).was.notCalled();
    });
    it('should reject the Deferred on disposal', function() {
      var failSpy;
      model.initDeferred();
      failSpy = sinon.spy();
      model.fail(failSpy);
      model.dispose();
      expect(model.state()).to.be('rejected');
      return expect(failSpy).was.called();
    });
    return it('should remove instance properties', function() {
      var prop, properties, _i, _len, _results;
      model.dispose();
      properties = ['collection', 'attributes', 'changed', '_escapedAttributes', '_previousAttributes', '_silent', '_pending', '_callbacks'];
      _results = [];
      for (_i = 0, _len = properties.length; _i < _len; _i++) {
        prop = properties[_i];
        _results.push(expect(_(model).has(prop)).to.not.be.ok());
      }
      return _results;
    });
  });
});
