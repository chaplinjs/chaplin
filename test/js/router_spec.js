// Generated by CoffeeScript 1.4.0

define(['underscore', 'chaplin/mediator', 'chaplin/lib/router', 'chaplin/lib/route'], function(_, mediator, Router, Route) {
  'use strict';
  return describe('Router and Route', function() {
    var matchRoute, params, route, router;
    router = route = params = null;
    matchRoute = function(_route, _params) {
      route = _route;
      return params = _params;
    };
    beforeEach(function() {
      router = new Router({
        randomOption: 'foo'
      });
      return mediator.subscribe('matchRoute', matchRoute);
    });
    afterEach(function() {
      route = params = null;
      router.dispose();
      return mediator.unsubscribe('matchRoute', matchRoute);
    });
    it('should create a Backbone.History instance', function() {
      return expect(Backbone.history).to.be.a(Backbone.History);
    });
    it('should not start the Backbone.History at once', function() {
      return expect(Backbone.History.started).to.not.be.ok();
    });
    it('should allow to start the Backbone.History', function() {
      var spy;
      spy = sinon.spy(Backbone.history, 'start');
      expect(router.startHistory).to.be.a('function');
      router.startHistory();
      expect(Backbone.History.started).to.be(true);
      return expect(spy).was.called();
    });
    it('should default to pushState', function() {
      router.startHistory();
      expect(router.options).to.be.an('object');
      return expect(Backbone.history.options.pushState).to.be(router.options.pushState);
    });
    it('should pass the options to the Backbone.History instance', function() {
      router.startHistory();
      return expect(Backbone.history.options.randomOption).to.be('foo');
    });
    it('should allow to stop the Backbone.History', function() {
      var spy;
      router.startHistory();
      spy = sinon.spy(Backbone.history, 'stop');
      expect(router.stopHistory).to.be.a('function');
      router.stopHistory();
      expect(Backbone.History.started).to.not.be.ok();
      return expect(spy).was.called();
    });
    it('should have a match method which returns a route', function() {
      expect(router.match).to.be.a('function');
      route = router.match('', 'null#null');
      return expect(route).to.be.a(Route);
    });
    it('should fire a matchRoute event when a route matches', function() {
      var spy;
      spy = sinon.spy();
      mediator.subscribe('matchRoute', spy);
      router.match('', 'null#null');
      router.route('/');
      expect(spy).was.called();
      return mediator.unsubscribe('matchRoute', spy);
    });
    it('should match correctly', function() {
      var routed, spy;
      spy = sinon.spy();
      mediator.subscribe('matchRoute', spy);
      router.match('correct-match1', 'null#null');
      router.match('correct-match2', 'null#null');
      routed = router.route('/correct-match1');
      expect(routed).to.be(true);
      expect(spy.callCount).to.be(1);
      return mediator.unsubscribe('matchRoute', spy);
    });
    it('should match in order specified when calling router.route', function() {
      var routed, spy;
      spy = sinon.spy();
      mediator.subscribe('matchRoute', spy);
      router.match('params/:one', 'null#null');
      router.match('params/:two', 'null#null');
      routed = router.route('/params/1');
      expect(routed).to.be(true);
      expect(spy.callCount).to.be(1);
      expect(params.one).to.be('1');
      expect(params.two).to.be(void 0);
      return mediator.unsubscribe('matchRoute', spy);
    });
    it('should match in order specified when called by Backbone.History', function() {
      var routed, spy;
      spy = sinon.spy();
      mediator.subscribe('matchRoute', spy);
      router.match('params/:one', 'null#null');
      router.match('params/:two', 'null#null');
      router.startHistory();
      routed = Backbone.history.loadUrl('/params/1');
      expect(routed).to.be(true);
      expect(spy.callCount).to.be(1);
      expect(params.one).to.be('1');
      expect(params.two).to.be(void 0);
      return mediator.unsubscribe('matchRoute', spy);
    });
    it('should reject reserved controller action names', function() {
      var prop, _i, _len, _ref, _results;
      _ref = ['constructor', 'initialize', 'redirectTo', 'dispose'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        prop = _ref[_i];
        _results.push(expect(function() {
          return router.match('', "null#" + prop);
        }).to.throwError());
      }
      return _results;
    });
    it('should pass the route to the matchRoute handler', function() {
      router.match('passing-the-route', 'null#null');
      router.route('/passing-the-route');
      return expect(route).to.be.a(Route);
    });
    it('should provide controller name and action', function() {
      router.match('controller/action', 'controller#action');
      router.route('/controller/action');
      expect(route.controller).to.be('controller');
      return expect(route.action).to.be('action');
    });
    it('should accept a regular expression as pattern', function() {
      router.match(/^(\w+)\/(\w+)\/(\w+)$/, 'null#null');
      router.route('/raw/regular/expression');
      expect(params).to.be.an('object');
      expect(params[0]).to.be('raw');
      expect(params[1]).to.be('regular');
      return expect(params[2]).to.be('expression');
    });
    it('should accept a empty regular expression as catch-all', function() {
      router.match('', 'null#null');
      router.match(/(?:)/, 'null#null');
      router.route("" + (Math.random()));
      return expect(params).to.be.an('object');
    });
    it('should extract named parameters', function() {
      router.match('params/:one/:p_two_123/three', 'null#null');
      router.route('/params/123-foo/456-bar/three');
      expect(params).to.be.an('object');
      expect(params.one).to.be('123-foo');
      return expect(params.p_two_123).to.be('456-bar');
    });
    it('should extract non-ascii named parameters', function() {
      router.match('params/:one/:two/:three/:four', 'null#null');
      router.route("/params/o_O/*.*/ü~ö~ä/" + (encodeURIComponent('éêè')));
      expect(params).to.be.an('object');
      expect(params.one).to.be('o_O');
      expect(params.two).to.be('*.*');
      expect(params.three).to.be('ü~ö~ä');
      return expect(params.four).to.be(encodeURIComponent('éêè'));
    });
    it('should match splat parameters', function() {
      router.match('params/:one/*two', 'null#null');
      router.route('/params/123-foo/456-bar/789-qux');
      expect(params).to.be.an('object');
      expect(params.one).to.be('123-foo');
      return expect(params.two).to.be('456-bar/789-qux');
    });
    it('should match splat parameters at the beginning', function() {
      router.match('params/*one/:two', 'null#null');
      router.route('/params/123-foo/456-bar/789-qux');
      expect(params).to.be.an('object');
      expect(params.one).to.be('123-foo/456-bar');
      return expect(params.two).to.be('789-qux');
    });
    it('should match splat parameters before a named parameter', function() {
      router.match('params/*one:two', 'null#null');
      router.route('/params/123-foo/456-bar/789-qux');
      expect(params).to.be.an('object');
      expect(params.one).to.be('123-foo/456-bar/');
      return expect(params.two).to.be('789-qux');
    });
    it('should impose constraints', function() {
      var spy;
      spy = sinon.spy();
      mediator.subscribe('matchRoute', spy);
      router.match('constraints/:id', 'null#null', {
        constraints: {
          id: /^\d+$/
        }
      });
      router.route('/constraints/123-foo');
      expect(spy).was.notCalled();
      router.route('/constraints/123');
      expect(spy).was.called();
      return mediator.unsubscribe('matchRoute', spy);
    });
    it('should pass fixed parameters', function() {
      router.match('fixed-params/:id', 'null#null', {
        params: {
          foo: 'bar'
        }
      });
      router.route('/fixed-params/123');
      expect(params.id).to.be('123');
      return expect(params.foo).to.be('bar');
    });
    it('should not overwrite fixed parameters', function() {
      router.match('conflicting-params/:foo', 'null#null', {
        params: {
          foo: 'bar'
        }
      });
      router.route('/conflicting-params/123');
      return expect(params.foo).to.be('bar');
    });
    it('should pass query string parameters', function() {
      var input, queryString;
      router.match('query-string', 'null#null');
      input = {
        foo: '123 456',
        'b a r': 'the _quick &brown föx= jumps over the lazy dáwg',
        'q&uu=x': 'the _quick &brown föx= jumps over the lazy dáwg'
      };
      queryString = _(input).reduce(function(memo, val, prop) {
        return memo + (memo === '?' ? '' : '&') + encodeURIComponent(prop) + '=' + encodeURIComponent(val);
      }, '?');
      router.route("query-string" + queryString);
      expect(params.foo).to.be(input.foo);
      expect(params.bar).to.be(input.bar);
      return expect(params['q&uu=x']).to.be(input['q&uu=x']);
    });
    it('should extract named parameters along with query params', function() {
      router.match('params/:one', 'null#null');
      router.route('/params/named?foo=query123&bar=query_456&qux=789%20query');
      expect(params).to.be.an('object');
      expect(params.one).to.be('named');
      expect(params.foo).to.be('query123');
      expect(params.bar).to.be('query_456');
      return expect(params.qux).to.be('789 query');
    });
    it('should extract named parameters along with splats', function() {
      router.match('params/*one', 'null#null');
      router.route('/params/foo/bar/qux?foo=query123&bar=query_456&qux=789%20query');
      expect(params).to.be.an('object');
      expect(params.one).to.be('foo/bar/qux');
      expect(params.foo).to.be('query123');
      expect(params.bar).to.be('query_456');
      return expect(params.qux).to.be('789 query');
    });
    it('should listen to the !router:route event', function() {
      var path, spy;
      path = 'router-route-events';
      sinon.spy(router, 'route');
      spy = sinon.spy();
      router.match(path, 'router#route');
      mediator.publish('!router:route', path, spy);
      expect(router.route).was.calledWith(path);
      expect(spy).was.calledWith(true);
      expect(route.controller).to.be('router');
      expect(route.action).to.be('route');
      spy = sinon.spy();
      mediator.publish('!router:route', 'different-path', spy);
      return expect(spy).was.calledWith(false);
    });
    it('should listen to the !router:changeURL event', function() {
      var path;
      path = 'router-changeurl-events';
      sinon.spy(router, 'changeURL');
      mediator.publish('!router:changeURL', path);
      return expect(router.changeURL).was.calledWith(path);
    });
    it('should dispose itself correctly', function() {
      expect(router.dispose).to.be.a('function');
      router.dispose();
      expect(Backbone.history).to.be(void 0);
      expect(function() {
        return router.match('', 'null#null');
      }).to.throwError();
      expect(function() {
        return router.route('/');
      }).to.throwError();
      expect(router.disposed).to.be(true);
      if (Object.isFrozen) {
        return expect(Object.isFrozen(router)).to.be(true);
      }
    });
    return it('should be extendable', function() {
      var DerivedRoute, DerivedRouter, derivedRoute, derivedRouter;
      expect(Router.extend).to.be.a('function');
      expect(Route.extend).to.be.a('function');
      DerivedRouter = Router.extend();
      derivedRouter = new DerivedRouter();
      expect(derivedRouter).to.be.a(Router);
      DerivedRoute = Route.extend();
      derivedRoute = new DerivedRoute('foo', 'foo#bar');
      expect(derivedRoute).to.be.a(Route);
      return derivedRouter.dispose();
    });
  });
});
