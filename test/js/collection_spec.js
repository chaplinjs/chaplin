// Generated by CoffeeScript 1.4.0
var __hasProp = {}.hasOwnProperty;

define(['underscore', 'backbone', 'chaplin/mediator', 'chaplin/models/collection', 'chaplin/models/model', 'chaplin/lib/event_broker'], function(_, Backbone, mediator, Collection, Model, EventBroker) {
  'use strict';
  return describe('Collection', function() {
    var collection, expectOrder;
    collection = null;
    beforeEach(function() {
      return collection = new Collection;
    });
    afterEach(function() {
      return collection.dispose();
    });
    expectOrder = function(order) {
      var id, index, _i, _len, _results;
      _results = [];
      for (index = _i = 0, _len = order.length; _i < _len; index = ++_i) {
        id = order[index];
        _results.push(expect(collection.at(index).id).to.be(id));
      }
      return _results;
    };
    it('should mixin a EventBroker', function() {
      var name, value, _results;
      _results = [];
      for (name in EventBroker) {
        if (!__hasProp.call(EventBroker, name)) continue;
        value = EventBroker[name];
        _results.push(expect(collection[name]).to.be(EventBroker[name]));
      }
      return _results;
    });
    it('should initialize a Deferred', function() {
      var method, _i, _len, _ref;
      expect(collection.initDeferred).to.be.a('function');
      collection.initDeferred();
      _ref = ['done', 'fail', 'progress', 'state', 'promise'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        method = _ref[_i];
        expect(typeof collection[method]).to.be('function');
      }
      return expect(collection.state()).to.be('pending');
    });
    it('should add models atomically', function() {
      var addSpy, i, resetSpy;
      expect(collection.addAtomic).to.be.a('function');
      collection.reset((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i <= 2; i = ++_i) {
          _results.push({
            id: i
          });
        }
        return _results;
      })());
      addSpy = sinon.spy();
      collection.on('add', addSpy);
      resetSpy = sinon.spy();
      collection.on('reset', resetSpy);
      collection.addAtomic((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 3; _i <= 5; i = ++_i) {
          _results.push({
            id: i
          });
        }
        return _results;
      })());
      expectOrder([0, 1, 2, 3, 4, 5]);
      expect(addSpy).was.notCalled();
      return expect(resetSpy).was.called();
    });
    it('should add models atomically at a specific position', function() {
      var addSpy, i, resetSpy;
      collection.reset((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i <= 2; i = ++_i) {
          _results.push({
            id: i
          });
        }
        return _results;
      })());
      addSpy = sinon.spy();
      collection.on('add', addSpy);
      resetSpy = sinon.spy();
      collection.on('reset', resetSpy);
      collection.addAtomic((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 3; _i <= 5; i = ++_i) {
          _results.push({
            id: i
          });
        }
        return _results;
      })(), {
        at: 1
      });
      expectOrder([0, 3, 4, 5, 1, 2]);
      expect(addSpy).was.notCalled();
      return expect(resetSpy).was.called();
    });
    it('should update models', function() {
      var addSpy, i, newOrder, removeSpy, resetSpy;
      expect(collection.update).to.be.a('function');
      collection.reset((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i <= 5; i = ++_i) {
          _results.push({
            id: i
          });
        }
        return _results;
      })());
      addSpy = sinon.spy();
      collection.on('add', addSpy);
      removeSpy = sinon.spy();
      collection.on('remove', removeSpy);
      resetSpy = sinon.spy();
      collection.on('reset', resetSpy);
      newOrder = [1, 3, 5, 7, 9, 11];
      collection.update((function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = newOrder.length; _i < _len; _i++) {
          i = newOrder[_i];
          _results.push({
            id: i
          });
        }
        return _results;
      })());
      expectOrder(newOrder);
      expect(addSpy.callCount).to.be(3);
      expect(removeSpy.callCount).to.be(3);
      return expect(resetSpy).was.notCalled();
    });
    it('should update models deeply', function() {
      var i, id, model, models, newOrder, _i, _j, _len, _len1, _ref, _ref1, _results;
      collection.reset((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 0; _i <= 5; i = ++_i) {
          _results.push({
            id: i,
            old1: true,
            old2: false
          });
        }
        return _results;
      })());
      newOrder = [1, 3, 5, 7, 9, 11];
      models = (function() {
        var _i, _len, _results;
        _results = [];
        for (_i = 0, _len = newOrder.length; _i < _len; _i++) {
          i = newOrder[_i];
          _results.push({
            id: i,
            old2: true,
            "new": true
          });
        }
        return _results;
      })();
      collection.update(models, {
        deep: true
      });
      expectOrder(newOrder);
      _ref = [1, 3, 5];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        id = _ref[_i];
        model = collection.get(id);
        expect(model.get('old1')).to.be(true);
        expect(model.get('old2')).to.be(true);
        expect(model.get('new')).to.be(true);
      }
      _ref1 = [7, 9, 11];
      _results = [];
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        id = _ref1[_j];
        model = collection.get(id);
        expect(model.get('old1')).to.be(void 0);
        expect(model.get('old2')).to.be(true);
        _results.push(expect(model.get('new')).to.be(true));
      }
      return _results;
    });
    it('should serialize the models', function() {
      var actual, expected, model1, model2;
      model1 = new Model({
        id: 1,
        foo: 'foo'
      });
      model2 = new Backbone.Model({
        id: 2,
        bar: 'bar'
      });
      collection = new Collection([model1, model2]);
      expect(collection.serialize).to.be.a('function');
      actual = collection.serialize();
      expected = [
        {
          id: 1,
          foo: 'foo'
        }, {
          id: 2,
          bar: 'bar'
        }
      ];
      expect(actual.length).to.be(expected.length);
      expect(actual[0]).to.be.an('object');
      expect(actual[0].id).to.be(expected[0].id);
      expect(actual[0].foo).to.be(expected[0].foo);
      expect(actual[1]).to.be.an('object');
      expect(actual[1].id).to.be(expected[1].id);
      return expect(actual[1].foo).to.be(expected[1].foo);
    });
    it('should dispose itself correctly', function() {
      expect(collection.dispose).to.be.a('function');
      collection.dispose();
      expect(collection.length).to.be(0);
      expect(collection.disposed).to.be(true);
      if (Object.isFrozen) {
        return expect(Object.isFrozen(collection)).to.be(true);
      }
    });
    it('should fire a dispose event', function() {
      var disposeSpy;
      disposeSpy = sinon.spy();
      collection.on('dispose', disposeSpy);
      collection.dispose();
      return expect(disposeSpy).was.called();
    });
    it('should unsubscribe from Pub/Sub events', function() {
      var pubSubSpy;
      pubSubSpy = sinon.spy();
      collection.subscribeEvent('foo', pubSubSpy);
      collection.dispose();
      mediator.publish('foo');
      return expect(pubSubSpy).was.notCalled();
    });
    it('should remove all event handlers from itself', function() {
      var collectionBindSpy;
      collectionBindSpy = sinon.spy();
      collection.on('foo', collectionBindSpy);
      collection.dispose();
      collection.trigger('foo');
      return expect(collectionBindSpy).was.notCalled();
    });
    it('should reject the Deferred on disposal', function() {
      var failSpy;
      collection.initDeferred();
      failSpy = sinon.spy();
      collection.fail(failSpy);
      collection.dispose();
      expect(collection.state()).to.be('rejected');
      return expect(failSpy).was.called();
    });
    return it('should remove instance properties', function() {
      var prop, _i, _len, _ref, _results;
      collection.dispose();
      _ref = ['model', 'models', '_byId', '_byCid'];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        prop = _ref[_i];
        _results.push(expect(_(collection).has(prop)).to.not.be.ok());
      }
      return _results;
    });
  });
});
