// Generated by CoffeeScript 1.4.0
var __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

define(['underscore', 'jquery', 'backbone', 'chaplin/mediator', 'chaplin/views/view', 'chaplin/models/model', 'chaplin/models/collection', 'chaplin/lib/event_broker', 'chaplin/lib/sync_machine'], function(_, $, Backbone, mediator, View, Model, Collection, EventBroker, SyncMachine) {
  'use strict';
  return describe('View', function() {
    var ConfiguredTestView, TestView, bindAndTrigger, collection, model, renderCalled, setCollection, setModel, template, testbed, view;
    renderCalled = false;
    view = model = collection = null;
    template = '<p>content</p>';
    testbed = document.getElementById('testbed');
    beforeEach(function() {
      renderCalled = false;
      return view = new TestView;
    });
    afterEach(function() {
      view.dispose();
      view = null;
      if (model) {
        if (typeof model.dispose === "function") {
          model.dispose();
        }
        model = null;
      }
      if (collection) {
        if (typeof collection.dispose === "function") {
          collection.dispose();
        }
        return collection = null;
      }
    });
    setModel = function() {
      model = new Model({
        foo: 'foo',
        bar: 'bar'
      });
      return view.model = model;
    };
    setCollection = function() {
      collection = new Collection;
      return view.collection = collection;
    };
    TestView = (function(_super) {

      __extends(TestView, _super);

      function TestView() {
        return TestView.__super__.constructor.apply(this, arguments);
      }

      TestView.prototype.id = 'test-view';

      TestView.prototype.getTemplateFunction = function() {
        return function() {
          return template;
        };
      };

      TestView.prototype.initialize = function() {
        return TestView.__super__.initialize.apply(this, arguments);
      };

      TestView.prototype.render = function() {
        TestView.__super__.render.apply(this, arguments);
        return renderCalled = true;
      };

      return TestView;

    })(View);
    ConfiguredTestView = (function(_super) {

      __extends(ConfiguredTestView, _super);

      function ConfiguredTestView() {
        return ConfiguredTestView.__super__.constructor.apply(this, arguments);
      }

      ConfiguredTestView.prototype.autoRender = true;

      ConfiguredTestView.prototype.container = '#testbed';

      ConfiguredTestView.prototype.containerMethod = 'before';

      return ConfiguredTestView;

    })(TestView);
    it('should mixin a EventBroker', function() {
      var name, value, _results;
      _results = [];
      for (name in EventBroker) {
        if (!__hasProp.call(EventBroker, name)) continue;
        value = EventBroker[name];
        _results.push(expect(view[name]).to.be(EventBroker[name]));
      }
      return _results;
    });
    it('should render', function() {
      var renderResult;
      expect(view.render).to.be.a('function');
      renderResult = view.render();
      return expect(renderResult).to.be(view);
    });
    it('should render a template', function() {
      var innerHTML, lowerCaseTemplate;
      view.render();
      innerHTML = view.$el.html().toLowerCase();
      lowerCaseTemplate = template.toLowerCase();
      return expect(innerHTML).to.be(lowerCaseTemplate);
    });
    it('should render automatically', function() {
      view = new TestView({
        autoRender: true
      });
      expect(renderCalled).to.be(true);
      return expect(view.$el.parent().length).to.be(0);
    });
    it('should attach itself to an element automatically', function() {
      view = new TestView({
        container: testbed
      });
      expect(renderCalled).to.not.be.ok();
      expect(view.el.parentNode).to.be(null);
      view.render();
      return expect(view.el.parentNode).to.be(testbed);
    });
    it('should attach itself to a selector automatically', function() {
      view = new TestView({
        container: '#testbed'
      });
      view.render();
      return expect(view.el.parentNode).to.be(testbed);
    });
    it('should attach itself to a jQuery object automatically', function() {
      view = new TestView({
        container: $('#testbed')
      });
      view.render();
      return expect(view.el.parentNode).to.be(testbed);
    });
    it('should use the given attach method', function() {
      view = new TestView({
        container: testbed,
        containerMethod: 'after'
      });
      view.render();
      expect(view.el).to.be(testbed.nextSibling);
      return expect(view.el.parentNode).to.be(testbed.parentNode);
    });
    it('should consider autoRender, container and containerMethod properties', function() {
      view = new ConfiguredTestView();
      expect(renderCalled).to.be(true);
      expect(view.el).to.be(testbed.previousSibling);
      return expect(view.el.parentNode).to.be(testbed.parentNode);
    });
    it('should fire an addedToDOM event attching itself to the DOM', function() {
      var spy;
      view = new TestView({
        container: testbed
      });
      spy = sinon.spy();
      view.on('addedToDOM', spy);
      view.render();
      return expect(spy).was.called();
    });
    it('should register and remove user input event handlers', function() {
      var handler, p, spy;
      expect(view.delegate).to.be.a('function');
      expect(view.undelegate).to.be.a('function');
      spy = sinon.spy();
      handler = view.delegate('click', spy);
      expect(handler).to.be.a('function');
      $(view.el).trigger('click');
      expect(spy).was.called();
      view.undelegate();
      $(view.el).trigger('click');
      expect(spy.callCount).to.be(1);
      view.render();
      spy = sinon.spy();
      handler = view.delegate('click', 'p', spy);
      expect(handler).to.be.a('function');
      p = view.$('p');
      expect(p.length).to.be(1);
      p.trigger('click');
      expect(spy).was.called();
      view.undelegate();
      p.trigger('click');
      return expect(spy.callCount).to.be(1);
    });
    it('should register and remove multiple user input event handlers', function() {
      var handler, spy;
      spy = sinon.spy();
      handler = view.delegate('click keypress', spy);
      $(view.el).trigger('click');
      $(view.el).trigger('keypress');
      expect(spy).was.calledTwice();
      view.undelegate();
      $(view.el).trigger('click');
      $(view.el).trigger('keypress');
      return expect(spy).was.calledTwice();
    });
    it('should check delegate parameters', function() {
      expect(function() {
        return view.delegate();
      }).to.throwError();
      expect(function() {
        return view.delegate(1, 2, 3);
      }).to.throwError();
      expect(function() {
        return view.delegate('click', 'foo');
      }).to.throwError();
      expect(function() {
        return view.delegate('click', 'foo', 'bar');
      }).to.throwError();
      expect(function() {
        return view.delegate('click', 123);
      }).to.throwError();
      return expect(function() {
        return view.delegate('click', (function() {}), 123);
      }).to.throwError();
    });
    it('should bind handlers to model events', function() {
      var spy;
      expect(view.modelBind).to.be.a('function');
      expect(function() {
        return view.modelBind();
      }).to.throwError();
      expect(function() {
        return view.modelBind(1, 2);
      }).to.throwError();
      expect(function() {
        return view.modelBind(1, function() {});
      }).to.throwError();
      expect(function() {
        return view.modelBind('change:foo', function() {});
      }).to.throwError();
      setModel();
      spy = sinon.spy();
      view.modelBind('change:foo', spy);
      model.set({
        foo: 'bar'
      });
      expect(spy).was.called();
      view.modelBind('change:foo', spy);
      model.set({
        foo: 'qux'
      });
      return expect(spy.callCount).to.be(2);
    });
    it('should bind handlers to collection events', function() {
      var spy;
      setCollection();
      spy = sinon.spy();
      view.modelBind('add', spy);
      collection.push(new Model());
      return expect(spy).was.called();
    });
    it('should unbind handlers from model events', function() {
      var spy;
      expect(view.modelUnbind).to.be.a('function');
      setModel();
      spy = sinon.spy();
      view.modelBind('change:foo', spy);
      view.modelUnbind('change:foo', spy);
      model.set({
        foo: 'bar'
      });
      return expect(spy).was.notCalled();
    });
    it('should unbind handlers from collection events', function() {
      var spy;
      setCollection();
      spy = sinon.spy();
      view.modelBind('add', spy);
      view.modelUnbind('add', spy);
      collection.push(new Model());
      return expect(spy).was.notCalled();
    });
    it('should force the context of model event handlers', function() {
      var context;
      setModel();
      context = null;
      view.modelBind('foo', function() {
        return context = this;
      });
      model.trigger('foo');
      return expect(context).to.be(view);
    });
    bindAndTrigger = function(model, view) {
      var allSpy, barSpy, fooSpy;
      fooSpy = sinon.spy();
      view.modelBind('foo', fooSpy);
      barSpy = sinon.spy();
      view.modelBind('bar', barSpy);
      allSpy = sinon.spy();
      view.modelBind('all', allSpy);
      model.trigger('foo bar');
      expect(fooSpy.callCount).to.be(1);
      expect(barSpy.callCount).to.be(1);
      expect(allSpy.callCount).to.be(2);
      view.modelUnbindAll();
      view.trigger('foo bar');
      expect(fooSpy.callCount).to.be(1);
      expect(barSpy.callCount).to.be(1);
      return expect(allSpy.callCount).to.be(2);
    };
    it('should unbind all model handlers', function() {
      expect(view.modelUnbindAll).to.be.a('function');
      setModel();
      return bindAndTrigger(model, view);
    });
    it('should unbind all collection handlers', function() {
      setCollection();
      bindAndTrigger(collection, view);
      return collection.dispose();
    });
    it('should pass model attributes to elements', function() {
      var p;
      expect(view.pass).to.be.a('function');
      setModel();
      view.pass('foo', 'p');
      view.render();
      p = view.$('p');
      expect(p.text()).to.be('content');
      model.set({
        foo: 'bar'
      });
      return expect(p.text()).to.be('bar');
    });
    it('should pass model attributes to input elements', function() {
      var input;
      setModel();
      view.$el.html('<p><input type="text" id="foo"></p>');
      view.pass('foo', '#foo');
      input = view.$('input');
      expect(input.val()).to.be('');
      model.set({
        foo: 'bar'
      });
      return expect(input.val()).to.be('bar');
    });
    it('should add and return subviews', function() {
      var subview, subview2;
      expect(view.subview).to.be.a('function');
      subview = new View();
      view.subview('fooSubview', subview);
      expect(view.subview('fooSubview')).to.be(subview);
      expect(view.subviews.length).to.be(1);
      subview2 = new View();
      view.subview('fooSubview', subview2);
      expect(view.subview('fooSubview')).to.be(subview2);
      return expect(view.subviews.length).to.be(1);
    });
    it('should remove subviews', function() {
      var subview;
      expect(view.removeSubview).to.be.a('function');
      subview = new View();
      view.subview('fooSubview', subview);
      view.removeSubview('fooSubview');
      expect(typeof view.subview('fooSubview')).to.be('undefined');
      expect(view.subviews.length).to.be(0);
      subview = new View();
      view.subview('barSubview', subview);
      view.removeSubview(subview);
      expect(typeof view.subview('barSubview')).to.be('undefined');
      return expect(view.subviews.length).to.be(0);
    });
    it('should return empty template data without a model', function() {
      var templateData;
      templateData = view.getTemplateData();
      expect(templateData).to.be.an('object');
      return expect(_.isEmpty(templateData)).to.be(true);
    });
    it('should return proper template data for a Chaplin model', function() {
      var templateData;
      setModel();
      templateData = view.getTemplateData();
      expect(templateData).to.be.an('object');
      expect(templateData.foo).to.be('foo');
      return expect(templateData.bar).to.be('bar');
    });
    it('should return template data that protects the model', function() {
      var templateData;
      setModel();
      templateData = view.getTemplateData();
      templateData.qux = 'qux';
      return expect(model.get('qux')).to.be(void 0);
    });
    it('should return proper template data for a Backbone model', function() {
      var templateData;
      model = new Backbone.Model({
        foo: 'foo',
        bar: 'bar'
      });
      view.model = model;
      templateData = view.getTemplateData();
      expect(templateData).to.be.an('object');
      expect(templateData.foo).to.be('foo');
      return expect(templateData.bar).to.be('bar');
    });
    it('should return proper template data for Chaplin collections', function() {
      var d, items, model1, model2;
      model1 = new Model({
        foo: 'foo'
      });
      model2 = new Model({
        bar: 'bar'
      });
      collection = new Collection([model1, model2]);
      view.collection = collection;
      d = view.getTemplateData();
      expect(d).to.be.an('object');
      expect(d).to.only.have.keys('items');
      items = d.items;
      expect(items).to.be.an('array');
      expect(items.length).to.be(2);
      expect(items[0]).to.be.an('object');
      expect(items[0].foo).to.be('foo');
      expect(items[1]).to.be.an('object');
      return expect(items[1].bar).to.be('bar');
    });
    it('should return proper template data for Backbone collections', function() {
      var d, items, model1, model2;
      model1 = new Backbone.Model({
        foo: 'foo'
      });
      model2 = new Backbone.Model({
        bar: 'bar'
      });
      collection = new Backbone.Collection([model1, model2]);
      view.collection = collection;
      d = view.getTemplateData();
      expect(d).to.be.an('object');
      expect(d).to.only.have.keys('items');
      items = d.items;
      expect(items).to.be.an('array');
      expect(items.length).to.be(2);
      expect(items[0]).to.be.an('object');
      expect(items[0].foo).to.be('foo');
      expect(items[1]).to.be.an('object');
      return expect(items[1].bar).to.be('bar');
    });
    it('should add the Deferred state to the template data', function() {
      var templateData;
      setModel();
      model.initDeferred();
      templateData = view.getTemplateData();
      expect(templateData.resolved).to.not.be.ok();
      model.resolve();
      templateData = view.getTemplateData();
      return expect(templateData.resolved).to.be(true);
    });
    it('should add the SyncMachine state to the template data', function() {
      var templateData;
      setModel();
      _.extend(model, SyncMachine);
      templateData = view.getTemplateData();
      expect(templateData.synced).to.not.be.ok();
      model.beginSync();
      model.finishSync();
      templateData = view.getTemplateData();
      return expect(templateData.synced).to.be(true);
    });
    it('should not cover existing synced and resolved properties', function() {
      var templateData;
      setModel();
      model.initDeferred();
      _.extend(model, SyncMachine);
      model.set({
        resolved: 'foo',
        synced: 'bar'
      });
      templateData = view.getTemplateData();
      expect(templateData.resolved).to.be('foo');
      return expect(templateData.synced).to.be('bar');
    });
    it('should pass model attributes to the template function', function() {
      var passedTemplateData, templateData, templateFunc;
      setModel();
      sinon.spy(view, 'getTemplateData');
      passedTemplateData = null;
      templateFunc = sinon.stub().returns(template);
      sinon.stub(view, 'getTemplateFunction').returns(templateFunc);
      view.render();
      expect(view.getTemplateFunction).was.called();
      expect(view.getTemplateData).was.called();
      expect(templateFunc).was.called();
      templateData = templateFunc.lastCall.args[0];
      expect(templateData).to.be.an('object');
      expect(templateData.foo).to.be('foo');
      return expect(templateData.bar).to.be('bar');
    });
    it('should dispose itself correctly', function() {
      expect(view.dispose).to.be.a('function');
      view.dispose();
      expect(view.disposed).to.be(true);
      if (Object.isFrozen) {
        return expect(Object.isFrozen(view)).to.be(true);
      }
    });
    it('should remove itself from the DOM', function() {
      view.$el.attr('id', 'disposed-view').appendTo(document.body);
      expect($('#disposed-view').length).to.be(1);
      view.dispose();
      return expect($('#disposed-view').length).to.be(0);
    });
    it('should dispose subviews', function() {
      var subview;
      subview = new View();
      sinon.spy(subview, 'dispose');
      view.subview('foo', subview);
      view.dispose();
      expect(subview.disposed).to.be(true);
      return expect(subview.dispose).was.called();
    });
    it('should unsubscribe from Pub/Sub events', function() {
      var pubSubSpy;
      pubSubSpy = sinon.spy();
      view.subscribeEvent('foo', pubSubSpy);
      view.dispose();
      mediator.publish('foo');
      return expect(pubSubSpy).was.notCalled();
    });
    it('should unsubscribe from model events', function() {
      var modelBindSpy;
      setModel();
      modelBindSpy = sinon.spy();
      view.modelBind('foo', modelBindSpy);
      view.dispose();
      model.trigger('foo');
      return expect(modelBindSpy).was.notCalled();
    });
    it('should remove all event handlers from itself', function() {
      var viewBindSpy;
      viewBindSpy = sinon.spy();
      view.on('foo', viewBindSpy);
      view.dispose();
      view.trigger('foo');
      return expect(viewBindSpy).was.notCalled();
    });
    it('should remove instance properties', function() {
      var prop, properties, _i, _len, _results;
      view.dispose();
      properties = ['el', '$el', 'options', 'model', 'collection', 'subviews', 'subviewsByName', '_callbacks'];
      _results = [];
      for (_i = 0, _len = properties.length; _i < _len; _i++) {
        prop = properties[_i];
        _results.push(expect(_(view).has(prop)).to.not.be.ok());
      }
      return _results;
    });
    it('should dispose itself when the model or collection is disposed', function() {
      model = new Model();
      view = new TestView({
        model: model
      });
      model.dispose();
      expect(model.disposed).to.be(true);
      return expect(view.disposed).to.be(true);
    });
    it('should not render when disposed given render wasn’t overridden', function() {
      var renderResult;
      view = new View();
      view.getTemplateFunction = TestView.prototype.getTemplateFunction;
      sinon.spy(view, 'afterRender');
      renderResult = view.render();
      expect(renderResult).to.be(view);
      view.dispose();
      renderResult = view.render();
      expect(renderResult).to.not.be.ok();
      return expect(view.afterRender.callCount).to.be(1);
    });
    return it('should not render when disposed given render was overridden', function() {
      var renderResult;
      view = new TestView({
        container: '#testbed'
      });
      sinon.spy(view, 'afterRender');
      renderResult = view.render();
      expect(renderResult).to.be(view);
      expect(view.afterRender.callCount).to.be(1);
      expect(renderCalled).to.be(true);
      expect(view.el.parentNode).to.be(testbed);
      view.dispose();
      renderResult = view.render();
      expect(renderResult).to.not.be.ok();
      expect(renderCalled).to.be(true);
      expect($(testbed).children().length).to.be(0);
      return expect(view.afterRender.callCount).to.be(1);
    });
  });
});
