// Generated by CoffeeScript 1.4.0

define(['underscore', 'chaplin/lib/delayer'], function(_, Delayer) {
  'use strict';
  return describe('Delayer', function() {
    var delayer;
    delayer = {};
    _(delayer).extend(Delayer);
    it('should be a simple object', function() {
      return expect(Delayer).to.be.an('object');
    });
    it('should allow to set a timeout ', function(done) {
      var handle;
      expect(delayer.setTimeout).to.be.a('function');
      handle = delayer.setTimeout('foo', 1, function() {
        return done();
      });
      return expect(handle).to.be.a('number');
    });
    it('should create a timeout handle store', function(done) {
      expect(delayer.timeouts).to.be.an('object');
      delayer.setTimeout('foo', 1, function() {
        return done();
      });
      return expect(delayer.timeouts.foo).to.be.a('number');
    });
    it('should set multiple timeouts with different name', function(done) {
      var spy1, spy2;
      spy1 = sinon.spy();
      spy2 = sinon.spy();
      delayer.setTimeout('foo', 1, spy1);
      delayer.setTimeout('bar', 1, spy2);
      return setTimeout(function() {
        expect(spy1).was.called();
        expect(spy2).was.called();
        return done();
      }, 1);
    });
    it('should not set a timeout twice', function(done) {
      var spy1, spy2;
      spy1 = sinon.spy();
      spy2 = sinon.spy();
      delayer.setTimeout('foo', 1, spy1);
      delayer.setTimeout('foo', 1, spy2);
      return setTimeout(function() {
        expect(spy1).was.notCalled();
        expect(spy2).was.called();
        return done();
      }, 1);
    });
    it('should remove called timeouts', function() {
      return expect(delayer.timeouts.foo).to.be(void 0);
    });
    it('should allow to clear a timeout', function(done) {
      var spy;
      spy = sinon.spy();
      delayer.setTimeout('foo', 1, spy);
      expect(delayer.clearTimeout).to.be.a('function');
      delayer.clearTimeout('foo');
      return setTimeout((function() {
        expect(spy).was.notCalled();
        return done();
      }), 1);
    });
    it('should clear all timeouts', function(done) {
      var spy1, spy2;
      spy1 = sinon.spy();
      spy2 = sinon.spy();
      delayer.setTimeout('foo', 1, spy1);
      delayer.setTimeout('bar', 1, spy2);
      expect(delayer.clearAllTimeouts).to.be.a('function');
      delayer.clearAllTimeouts();
      return setTimeout(function() {
        expect(spy1).was.notCalled();
        expect(spy2).was.notCalled();
        return done();
      }, 1);
    });
    it('should allow to set and get an interval', function() {
      var handle, setIntervalStub, spy;
      spy = sinon.spy();
      setIntervalStub = sinon.stub(window, 'setInterval').callsArg(0).returns(12345);
      expect(delayer.setInterval).to.be.a('function');
      handle = delayer.setInterval('foo', 50, spy);
      expect(handle).to.be(12345);
      expect(setIntervalStub).was.called();
      expect(spy).was.called();
      return setIntervalStub.restore();
    });
    it('should create a interval handle store', function() {
      var setIntervalStub;
      setIntervalStub = sinon.stub(window, 'setInterval').returns(12345);
      expect(delayer.intervals).to.be.an('object');
      delayer.setInterval('foo', 1, function() {});
      expect(delayer.intervals.foo).to.be(12345);
      return setIntervalStub.restore();
    });
    it('should allow to clear an interval', function() {
      var clearIntervalStub, handle, spy;
      spy = sinon.spy();
      clearIntervalStub = sinon.stub(window, 'clearInterval');
      handle = delayer.setInterval('foo', 1, spy);
      expect(delayer.clearInterval).to.be.a('function');
      delayer.clearInterval('foo');
      expect(clearIntervalStub).was.calledWith(handle);
      return clearIntervalStub.restore();
    });
    it('should clear all timeouts', function() {
      var clearIntervalStub, handle1, handle2, i, setIntervalStub;
      i = 0;
      setIntervalStub = sinon.stub(window, 'setInterval', function() {
        return ++i;
      });
      clearIntervalStub = sinon.stub(window, 'clearInterval');
      handle1 = delayer.setInterval('foo', 1, function() {});
      handle2 = delayer.setInterval('bar', 1, function() {});
      expect(delayer.clearAllIntervals).to.be.a('function');
      delayer.clearAllIntervals();
      expect(clearIntervalStub.callCount).to.be(2);
      expect(clearIntervalStub.getCall(0).args[0]).to.be(handle1);
      expect(clearIntervalStub.getCall(1).args[0]).to.be(handle2);
      setIntervalStub.restore();
      return clearIntervalStub.restore();
    });
    return it('should clear all timeouts and intervals', function() {
      var stub1, stub2;
      stub1 = sinon.stub(delayer, 'clearAllTimeouts');
      stub2 = sinon.stub(delayer, 'clearAllIntervals');
      expect(delayer.clearDelayed).to.be.a('function');
      delayer.clearDelayed();
      expect(stub1).was.called();
      expect(stub2).was.called();
      stub1.restore();
      return stub2.restore();
    });
  });
});
